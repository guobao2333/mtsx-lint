name: Run MTSX Lint (debug)

on:
  pull_request:
    paths:
      - 'mtsx/**/*.mtsx'
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  packages: read

jobs:
  run-linter:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to GHCR (for pulling)
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull linter image
        run: |
          docker pull ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest

      - name: Diagnose image and environment
        run: |
          echo "=== raku version in image ==="
          docker run --rm ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest raku --version || true
          echo "=== java version in image ==="
          docker run --rm ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest java -version || true
          echo "=== check jar presence inside image ==="
          docker run --rm ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest bash -lc 'if [ -f /opt/regex-checker.jar ]; then echo "/opt/regex-checker.jar exists"; ls -lh /opt/regex-checker.jar; else echo "/opt/regex-checker.jar NOT found"; fi' || true
          echo "=== list /workspace inside image (without mounting) ==="
          docker run --rm ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest bash -lc 'ls -la /workspace || true' || true

      - name: Run linter inside container (produce JSON + debug, safe)
        run: |
          echo "=== Starting debug-run (no host-side redirection) ==="
          echo "List workspace top-level:"
          ls -la "$GITHUB_WORKSPACE" || true

          # Run the safe wrapper inside the container; the wrapper writes files into /workspace (mounted)
          docker run --rm -v "${GITHUB_WORKSPACE}":/workspace -w /workspace ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest \
            /workspace/lint/run-linter-safe.sh --mode lenient --with-java /opt/regex-checker.jar --json
          RC=$?

          echo "linter wrapper exit code: $RC"

          echo "----- lint-run.log (tail) -----"
          if [ -f "$GITHUB_WORKSPACE/lint-run.log" ]; then
            tail -n 200 "$GITHUB_WORKSPACE/lint-run.log" || true
          else
            echo "(no lint-run.log produced)"
          fi

          echo "----- lint-result.json (head) -----"
          if [ -f "$GITHUB_WORKSPACE/lint-result.json" ]; then
            head -n 200 "$GITHUB_WORKSPACE/lint-result.json" || true
          else
            echo "(no lint-result.json produced)"
          fi

          # Validate json with jq if available
          if command -v jq >/dev/null 2>&1; then
            if [ -s "$GITHUB_WORKSPACE/lint-result.json" ] && jq -e . "$GITHUB_WORKSPACE/lint-result.json" >/dev/null 2>&1; then
              echo "lint-result.json is valid JSON"
            else
              echo "lint-result.json invalid or missing JSON"
              exit 1
            fi
          else
            # If jq not present, still fail if file missing or empty
            if [ ! -s "$GITHUB_WORKSPACE/lint-result.json" ]; then
              echo "lint-result.json missing or empty (jq not installed)"
              exit 1
            fi
          fi


      - name: Upload lint result artifact
        uses: actions/upload-artifact@v4
        with:
          name: lint-result
          path: |
            lint-result.json
            lint-result.sarif
            lint-run.log

      - name: Convert JSON -> SARIF (container)
        run: |
          if [ -s lint-result.json ]; then
            docker run --rm -v "${{ github.workspace }}":/workspace -w /workspace ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest                   bash -lc 'raku lint/json-to-sarif.raku lint-result.json lint-result.sarif || true'
          else
            echo "No lint-result.json to convert to SARIF"
          fi

      - name: Post or update PR comment with summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = 'lint-result.json';
            if (!fs.existsSync(path)) { core.info('No lint-result.json found'); return; }
            const r = JSON.parse(fs.readFileSync(path));
            const reports = r.reports || [];
            if (reports.length === 0) { core.info('No reports'); return; }
            let body = '## mtsx-lint Report\n';
            body += '\n_Source: automatic checks._\n\n';
            for (const rep of reports) {
              if ((rep.errors && rep.errors.length) || (rep.warnings && rep.warnings.length)) {
                body += `### ${rep.file}\n`;
                if (rep.errors && rep.errors.length) {
                  for (const e of rep.errors) { body += `- **ERROR**: ${e.message} (line:${e.line || '?'}, col:${e.col || '?'})\n`; }
                }
                if (rep.warnings && rep.warnings.length) {
                  for (const w of rep.warnings) { body += `- **WARN**: ${w.message} (line:${w.line || '?'}, col:${w.col || '?'})\n`; }
                }
                body += '\n';
              }
            }
            const marker = '<!-- mtsx-lint:comment -->';
            const comments = await github.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });
            const existing = comments.data.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: marker + '\n' + body
              });
            } else {
              await github.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: marker + '\n' + body
              });
            }
