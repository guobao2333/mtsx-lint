name: Run mtsx Lint

on:
  pull_request:
    paths:
      - 'mtsx/**/*.mtsx'
  push:
    paths:
      - 'mtsx/**/*.mtsx'
  workflow_dispatch:
    inputs:
      check_type:
        description: '检查类型'
        required: true
        default: 'lenient'
        type: choice
        options:
          - lenient
          - strict

permissions:
  contents: read
  issues: write
  packages: read # 从 GHCR 拉取镜像

jobs:
  run-linter:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Log in to GHCR (for pulling)
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull linter image
        run: |
          docker pull ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest

      - name: Run linter inside container (produce JSON)
        run: |
          docker run --rm -v "${GITHUB_WORKSPACE}":/workspace -w /workspace \
            ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest \
            raku lint/mtsx-lint.raku --mode ${{ inputs.check_type }} --with-java /opt/regex-checker.jar --json > lint-result.json

      - name: Convert JSON -> SARIF (container)
        run: |
          docker run --rm -v "${GITHUB_WORKSPACE}":/workspace -w /workspace \
            ghcr.io/${{ github.repository_owner }}/mtsx-linter:latest \
            raku lint/json-to-sarif.raku lint-result.json lint-result.sarif

      - name: Upload lint result artifact
        uses: actions/upload-artifact@v4
        with:
          name: lint-result
          path: |
            lint-result.json
            lint-result.sarif

      - name: Post or update PR comment with summary
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const path = 'lint-result.json';
            if (!fs.existsSync(path)) { core.info('No lint-result.json found'); return; }
            const r = JSON.parse(fs.readFileSync(path));
            const reports = r.reports || [];
            if (reports.length === 0) { core.info('No reports'); return; }
            let body = '## mtsx-lint Report\n\n_Source: automatic checks._\n\n';
            for (const rep of reports) {
              if ((rep.errors && rep.errors.length) || (rep.warnings && rep.warnings.length)) {
                body += `### ${rep.file}\n`;
                if (rep.errors && rep.errors.length) {
                  for (const e of rep.errors) { body += `- **ERROR**: ${e.message} (line:${e.line || '?'}, col:${e.col || '?'})\n`; }
                }
                if (rep.warnings && rep.warnings.length) {
                  for (const w of rep.warnings) { body += `- **WARN**: ${w.message} (line:${w.line || '?'}, col:${w.col || '?'})\n`; }
                }
                body += '\n';
              }
            }
            const marker = '<!-- mtsx-lint:comment -->';
            const comments = await github.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });
            const existing = comments.data.find(c => c.body && c.body.includes(marker));
            if (existing) {
              await github.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body: marker + '\n' + body
              });
            } else {
              await github.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: marker + '\n' + body
              });
            }
